// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package tradingpb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// TradingDB2Client is the client API for TradingDB2 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TradingDB2Client interface {
	// updCandles - update candles
	//      这个接口现在是覆盖的，不会和原有数据做任何合并操作
	UpdCandles(ctx context.Context, opts ...grpc.CallOption) (TradingDB2_UpdCandlesClient, error)
	// getCandles - get candles
	GetCandles(ctx context.Context, in *RequestGetCandles, opts ...grpc.CallOption) (TradingDB2_GetCandlesClient, error)
	// updSymbol - update symbol
	UpdSymbol(ctx context.Context, in *RequestUpdSymbol, opts ...grpc.CallOption) (*ReplyUpdSymbol, error)
	// getSymbol - get symbol
	GetSymbol(ctx context.Context, in *RequestGetSymbol, opts ...grpc.CallOption) (*ReplyGetSymbol, error)
	// getSymbols - get symbols
	GetSymbols(ctx context.Context, in *RequestGetSymbols, opts ...grpc.CallOption) (TradingDB2_GetSymbolsClient, error)
	// simTrading - simulation trading
	SimTrading(ctx context.Context, in *RequestSimTrading, opts ...grpc.CallOption) (*ReplySimTrading, error)
	// simTrading2 - simulation trading
	SimTrading2(ctx context.Context, opts ...grpc.CallOption) (TradingDB2_SimTrading2Client, error)
}

type tradingDB2Client struct {
	cc grpc.ClientConnInterface
}

func NewTradingDB2Client(cc grpc.ClientConnInterface) TradingDB2Client {
	return &tradingDB2Client{cc}
}

func (c *tradingDB2Client) UpdCandles(ctx context.Context, opts ...grpc.CallOption) (TradingDB2_UpdCandlesClient, error) {
	stream, err := c.cc.NewStream(ctx, &TradingDB2_ServiceDesc.Streams[0], "/tradingpb.TradingDB2/updCandles", opts...)
	if err != nil {
		return nil, err
	}
	x := &tradingDB2UpdCandlesClient{stream}
	return x, nil
}

type TradingDB2_UpdCandlesClient interface {
	Send(*RequestUpdCandles) error
	CloseAndRecv() (*ReplyUpdCandles, error)
	grpc.ClientStream
}

type tradingDB2UpdCandlesClient struct {
	grpc.ClientStream
}

func (x *tradingDB2UpdCandlesClient) Send(m *RequestUpdCandles) error {
	return x.ClientStream.SendMsg(m)
}

func (x *tradingDB2UpdCandlesClient) CloseAndRecv() (*ReplyUpdCandles, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(ReplyUpdCandles)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tradingDB2Client) GetCandles(ctx context.Context, in *RequestGetCandles, opts ...grpc.CallOption) (TradingDB2_GetCandlesClient, error) {
	stream, err := c.cc.NewStream(ctx, &TradingDB2_ServiceDesc.Streams[1], "/tradingpb.TradingDB2/getCandles", opts...)
	if err != nil {
		return nil, err
	}
	x := &tradingDB2GetCandlesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TradingDB2_GetCandlesClient interface {
	Recv() (*ReplyGetCandles, error)
	grpc.ClientStream
}

type tradingDB2GetCandlesClient struct {
	grpc.ClientStream
}

func (x *tradingDB2GetCandlesClient) Recv() (*ReplyGetCandles, error) {
	m := new(ReplyGetCandles)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tradingDB2Client) UpdSymbol(ctx context.Context, in *RequestUpdSymbol, opts ...grpc.CallOption) (*ReplyUpdSymbol, error) {
	out := new(ReplyUpdSymbol)
	err := c.cc.Invoke(ctx, "/tradingpb.TradingDB2/updSymbol", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDB2Client) GetSymbol(ctx context.Context, in *RequestGetSymbol, opts ...grpc.CallOption) (*ReplyGetSymbol, error) {
	out := new(ReplyGetSymbol)
	err := c.cc.Invoke(ctx, "/tradingpb.TradingDB2/getSymbol", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDB2Client) GetSymbols(ctx context.Context, in *RequestGetSymbols, opts ...grpc.CallOption) (TradingDB2_GetSymbolsClient, error) {
	stream, err := c.cc.NewStream(ctx, &TradingDB2_ServiceDesc.Streams[2], "/tradingpb.TradingDB2/getSymbols", opts...)
	if err != nil {
		return nil, err
	}
	x := &tradingDB2GetSymbolsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TradingDB2_GetSymbolsClient interface {
	Recv() (*ReplyGetSymbol, error)
	grpc.ClientStream
}

type tradingDB2GetSymbolsClient struct {
	grpc.ClientStream
}

func (x *tradingDB2GetSymbolsClient) Recv() (*ReplyGetSymbol, error) {
	m := new(ReplyGetSymbol)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tradingDB2Client) SimTrading(ctx context.Context, in *RequestSimTrading, opts ...grpc.CallOption) (*ReplySimTrading, error) {
	out := new(ReplySimTrading)
	err := c.cc.Invoke(ctx, "/tradingpb.TradingDB2/simTrading", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingDB2Client) SimTrading2(ctx context.Context, opts ...grpc.CallOption) (TradingDB2_SimTrading2Client, error) {
	stream, err := c.cc.NewStream(ctx, &TradingDB2_ServiceDesc.Streams[3], "/tradingpb.TradingDB2/simTrading2", opts...)
	if err != nil {
		return nil, err
	}
	x := &tradingDB2SimTrading2Client{stream}
	return x, nil
}

type TradingDB2_SimTrading2Client interface {
	Send(*RequestSimTrading) error
	Recv() (*ReplySimTrading, error)
	grpc.ClientStream
}

type tradingDB2SimTrading2Client struct {
	grpc.ClientStream
}

func (x *tradingDB2SimTrading2Client) Send(m *RequestSimTrading) error {
	return x.ClientStream.SendMsg(m)
}

func (x *tradingDB2SimTrading2Client) Recv() (*ReplySimTrading, error) {
	m := new(ReplySimTrading)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TradingDB2Server is the server API for TradingDB2 service.
// All implementations must embed UnimplementedTradingDB2Server
// for forward compatibility
type TradingDB2Server interface {
	// updCandles - update candles
	//      这个接口现在是覆盖的，不会和原有数据做任何合并操作
	UpdCandles(TradingDB2_UpdCandlesServer) error
	// getCandles - get candles
	GetCandles(*RequestGetCandles, TradingDB2_GetCandlesServer) error
	// updSymbol - update symbol
	UpdSymbol(context.Context, *RequestUpdSymbol) (*ReplyUpdSymbol, error)
	// getSymbol - get symbol
	GetSymbol(context.Context, *RequestGetSymbol) (*ReplyGetSymbol, error)
	// getSymbols - get symbols
	GetSymbols(*RequestGetSymbols, TradingDB2_GetSymbolsServer) error
	// simTrading - simulation trading
	SimTrading(context.Context, *RequestSimTrading) (*ReplySimTrading, error)
	// simTrading2 - simulation trading
	SimTrading2(TradingDB2_SimTrading2Server) error
	mustEmbedUnimplementedTradingDB2Server()
}

// UnimplementedTradingDB2Server must be embedded to have forward compatible implementations.
type UnimplementedTradingDB2Server struct {
}

func (UnimplementedTradingDB2Server) UpdCandles(TradingDB2_UpdCandlesServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdCandles not implemented")
}
func (UnimplementedTradingDB2Server) GetCandles(*RequestGetCandles, TradingDB2_GetCandlesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetCandles not implemented")
}
func (UnimplementedTradingDB2Server) UpdSymbol(context.Context, *RequestUpdSymbol) (*ReplyUpdSymbol, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdSymbol not implemented")
}
func (UnimplementedTradingDB2Server) GetSymbol(context.Context, *RequestGetSymbol) (*ReplyGetSymbol, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSymbol not implemented")
}
func (UnimplementedTradingDB2Server) GetSymbols(*RequestGetSymbols, TradingDB2_GetSymbolsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetSymbols not implemented")
}
func (UnimplementedTradingDB2Server) SimTrading(context.Context, *RequestSimTrading) (*ReplySimTrading, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SimTrading not implemented")
}
func (UnimplementedTradingDB2Server) SimTrading2(TradingDB2_SimTrading2Server) error {
	return status.Errorf(codes.Unimplemented, "method SimTrading2 not implemented")
}
func (UnimplementedTradingDB2Server) mustEmbedUnimplementedTradingDB2Server() {}

// UnsafeTradingDB2Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TradingDB2Server will
// result in compilation errors.
type UnsafeTradingDB2Server interface {
	mustEmbedUnimplementedTradingDB2Server()
}

func RegisterTradingDB2Server(s grpc.ServiceRegistrar, srv TradingDB2Server) {
	s.RegisterService(&TradingDB2_ServiceDesc, srv)
}

func _TradingDB2_UpdCandles_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TradingDB2Server).UpdCandles(&tradingDB2UpdCandlesServer{stream})
}

type TradingDB2_UpdCandlesServer interface {
	SendAndClose(*ReplyUpdCandles) error
	Recv() (*RequestUpdCandles, error)
	grpc.ServerStream
}

type tradingDB2UpdCandlesServer struct {
	grpc.ServerStream
}

func (x *tradingDB2UpdCandlesServer) SendAndClose(m *ReplyUpdCandles) error {
	return x.ServerStream.SendMsg(m)
}

func (x *tradingDB2UpdCandlesServer) Recv() (*RequestUpdCandles, error) {
	m := new(RequestUpdCandles)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _TradingDB2_GetCandles_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RequestGetCandles)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TradingDB2Server).GetCandles(m, &tradingDB2GetCandlesServer{stream})
}

type TradingDB2_GetCandlesServer interface {
	Send(*ReplyGetCandles) error
	grpc.ServerStream
}

type tradingDB2GetCandlesServer struct {
	grpc.ServerStream
}

func (x *tradingDB2GetCandlesServer) Send(m *ReplyGetCandles) error {
	return x.ServerStream.SendMsg(m)
}

func _TradingDB2_UpdSymbol_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestUpdSymbol)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDB2Server).UpdSymbol(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tradingpb.TradingDB2/updSymbol",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDB2Server).UpdSymbol(ctx, req.(*RequestUpdSymbol))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingDB2_GetSymbol_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGetSymbol)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDB2Server).GetSymbol(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tradingpb.TradingDB2/getSymbol",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDB2Server).GetSymbol(ctx, req.(*RequestGetSymbol))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingDB2_GetSymbols_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RequestGetSymbols)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TradingDB2Server).GetSymbols(m, &tradingDB2GetSymbolsServer{stream})
}

type TradingDB2_GetSymbolsServer interface {
	Send(*ReplyGetSymbol) error
	grpc.ServerStream
}

type tradingDB2GetSymbolsServer struct {
	grpc.ServerStream
}

func (x *tradingDB2GetSymbolsServer) Send(m *ReplyGetSymbol) error {
	return x.ServerStream.SendMsg(m)
}

func _TradingDB2_SimTrading_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestSimTrading)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingDB2Server).SimTrading(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tradingpb.TradingDB2/simTrading",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingDB2Server).SimTrading(ctx, req.(*RequestSimTrading))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingDB2_SimTrading2_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TradingDB2Server).SimTrading2(&tradingDB2SimTrading2Server{stream})
}

type TradingDB2_SimTrading2Server interface {
	Send(*ReplySimTrading) error
	Recv() (*RequestSimTrading, error)
	grpc.ServerStream
}

type tradingDB2SimTrading2Server struct {
	grpc.ServerStream
}

func (x *tradingDB2SimTrading2Server) Send(m *ReplySimTrading) error {
	return x.ServerStream.SendMsg(m)
}

func (x *tradingDB2SimTrading2Server) Recv() (*RequestSimTrading, error) {
	m := new(RequestSimTrading)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TradingDB2_ServiceDesc is the grpc.ServiceDesc for TradingDB2 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TradingDB2_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tradingpb.TradingDB2",
	HandlerType: (*TradingDB2Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "updSymbol",
			Handler:    _TradingDB2_UpdSymbol_Handler,
		},
		{
			MethodName: "getSymbol",
			Handler:    _TradingDB2_GetSymbol_Handler,
		},
		{
			MethodName: "simTrading",
			Handler:    _TradingDB2_SimTrading_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "updCandles",
			Handler:       _TradingDB2_UpdCandles_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "getCandles",
			Handler:       _TradingDB2_GetCandles_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "getSymbols",
			Handler:       _TradingDB2_GetSymbols_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "simTrading2",
			Handler:       _TradingDB2_SimTrading2_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "tradingdb2.proto",
}
